Shortest path algorithms are of central importance in Computer Science, and Dijkstra's Algorithm~\cite{dijkstra:note:1959}, being widely taught to undergraduates, is perhaps \emph{the} most famous algorithm in this class.
Most textbook presentations of Dijkstra's Algorithm (see, for example,~\cite[Chapter 24]{clrs}) are particularly concrete, presenting the algorithm as working over directed graphs with non-negative numeric arc weights.
Remarkably, however, the algorithm exists in a more general form where path weights are not numeric but drawn from a large class of \emph{semirings}~\cite{gondran_graphs_2008}.
A semiring $\langle S, \oplus, \otimes, 0, 1 \rangle$ is a structure comprised of a commutative monoid $\langle S, \oplus, 0\rangle$ and a monoid $\langle S, \otimes, 1\rangle$ such that two \emph{distributivity axioms} hold:
\begin{gather*}
a\otimes (b \oplus c) = (a\otimes b) \oplus (a\otimes c) \qquad
(b \oplus c) \otimes a = (b\otimes a) \oplus (c\otimes a)
\end{gather*}

In this generalised, algebraic setting a directed graph having $n$ nodes and arc weights in $S$ can be represented as a $n\times n$-matrix $\mathbf{A}$ over $S$, the graph's adjacency matrix where \(\mathbf{A}_{i,j}\) is the weight of the arc from node \(i\) to node \(j\).
Given a path $p = v_0, v_1, \ldots, v_k$---a sequence of nodes---its \emph{weight} is defined as
\begin{gather*}
    w_{\mathbf{A}}(p)
    \equiv
    \mathbf{A}(v_0,\ v_1)
    \otimes \mathbf{A}(v_1,\ v_2)
    \otimes \cdots
    \otimes \mathbf{A}(v_{k-1},\ v_k),
\end{gather*}
with the empty path assigned the weight $1$.
The generalised shortest-path problem is then to find a matrix $\mathbf{A}^*$ such that
\begin{gather*}
\label{eq:global}
\mathbf{A}^*(i,\ j) = \displaystyle\bigoplus_{p \in \pi(i,\ j)} w_{\mathbf{A}}(p)
\end{gather*}
where $\pi(i,\ j)$ represents the set of all paths from node $i$ to node $j$.
The matrix $\mathbf{A}^*$ need not always exist, but it is well known that if it does then it is a solution for $\mathbf{L}$ or $\mathbf{R}$ in the following left and right equations
\begin{gather*}
\mathbf{L} = (\mathbf{A} \otimes \mathbf{L}) \oplus \mathbf{I} \qquad\qquad
\mathbf{R} = (\mathbf{R} \otimes \mathbf{A}) \oplus \mathbf{I}
\end{gather*}
where $\mathbf{I}$ is the identity matrix and the multiplication and addition operations of the semiring have been lifted to matrix multiplication and addition in the obvious manner.

A nice feature of working in this algebraic setting is that the semiring parameterising the algorithm can be varied: some semirings cause the algorithm to compute shortest paths through the graph, \emph{a la} traditional presentations of Dijkstra, whereas other cause the algorithm to compute maximum bottleneck capacity, or some other feature of the graph.
The key idea here is that a generic, parametric implementation of a shortest path algorithm can be developed and then instantiated with different semirings, and thereafter uniformly used to calculate different properties of graphs.
The interested reader can find a thorough treatment of this material in~\cite{gondran_graphs_2008}.

The distributivity axioms,
Equations~\ref{eq:left:distributivity} and~\ref{eq:right:distributivity},
are essential in the semiring theory outlined above.
Thus it may seem suprising that recent research has shown that
the matrix equations ~\ref{eq:left:local} and ~\ref{eq:right:local}
can sometimes be solved even when
distributivity axioms do not hold in the algebraic structure employed.
Much of this work was originally motivated
by investigations of the Border Gateway Protocol (BGP),
the Internet routing protocol which has evolved to
maintain global connectivity between Internet Service Providers (ISPs).
In BGP the anologue of the weight of a path
$p = v_0, v_1, \cdots,\ v_k$ at node $v_0$
is dominated by the contractual relationships between
the networks associated with nodes $v_0$ and $v_1$.
The typical relationships involve those between customers
and providers and between competing ISPs (that must exchange
routing information in order to provide connectivity to
the global Internet).

But how can we interpret such solutions?
Take Equation~\ref{eq:left:local} for example.
If we assume that $\mathbf{L}$ solves this equation
and that $i \neq j$, then we have
\begin{equation}
\label{eq:left:local:at:i}
\mathbf{L}(i,\ j) = \displaystyle\bigoplus_{q \in N(i)} \mathbf{A}(i,\ q) \otimes \mathbf{L}(q,\ j),
\end{equation}
where $N(i)$ is the set of neighbors of node $i$.
We can interpret this from node $i$'s perspective as
the best path weight available given the paths its neighbors
have obtained.
That is, $\mathbf{L}$ does not represent the globally optimal
path weights, but rather an equilibrium point that we will
call \emph{locally optimal}.

\subsection{Generalising Dijkstra's algorithm}

\begin{figure}[ht]
\includegraphics{algorithm.pdf}
\caption{Dynerowicz and Griffin's imperative generalized Dijkstra's algorithm}
\label{fig.algorithm}
\end{figure}

\todo{finish me}

\paragraph{Agda}

Agda~\cite{norell_dependently_2009} is a dependently-typed functional programming language \emph{cum} proof assistant for higher-order intuitionistic logic.
In contrast to similar systems, such as Coq~\cite{bertot_short_2008} and Matita~\cite{asperti_matita_2011}, proof terms are constructed by hand via a process of type-directed refinement, rather than being constructed via tactic-assisted metaprogramming.

Agda has a uniform syntax that should be familiar to Haskell programmers and users of other dependently-typed proof assistants.
One syntactic novelty is a flexible system of user-declared Unicode mixfix identifiers~\cite{danielsson_parsing_2011} with `holes' in an identifier being denoted by underscores.
We write \AgdaSymbol{(}\AgdaBound{x}~\AgdaSymbol{:}~\AgdaBound{A}\AgdaSymbol{)}~\AgdaSymbol{→}~\AgdaBound{B} for the dependent function space where \AgdaBound{x} may occur in \AgdaBound{B}, and write \AgdaBound{A}~\AgdaSymbol{→}~\AgdaBound{B} when \AgdaBound{x} does not occur in \AgdaBound{B} as is usual.
We enclose arguments to be inferred in braces, as in \AgdaSymbol{\{}\AgdaBound{x}~\AgdaSymbol{:}~\AgdaBound{A}\AgdaSymbol{\}}~\AgdaSymbol{→}~\AgdaBound{B}, sometimes making use of the shorthands \AgdaSymbol{∀}~\AgdaBound{x}~\AgdaSymbol{→}~\AgdaBound{B} and \AgdaSymbol{∀}~\AgdaSymbol{\{}\AgdaBound{x}\AgdaSymbol{\}}~\AgdaSymbol{→}~\AgdaBound{B} when types can be inferred.
We write \AgdaDatatype{Σ}~\AgdaBound{A}~\AgdaBound{B} for the dependent sum type whose first projection has type \AgdaBound{A}, and write \AgdaBound{A}~\AgdaDatatype{×}~\AgdaBound{B} when the second projection does not depend on the first, as is usual.
Dependent sums are constructed using the comma constructor: \AgdaBound{x}~\AgdaInductiveConstructor{,}~\AgdaBound{y}.
We sometimes write \AgdaFunction{∃}~\AgdaSymbol{λ}~\AgdaBound{x}~\AgdaSymbol{→}~\AgdaBound{P} for the dependent sum type when the type of the first projection can be inferred.
Propositional equality between two types is written \AgdaBound{A}~\AgdaDatatype{≡}~\AgdaBound{B} and has a single canonical inhabitant, \AgdaInductiveConstructor{refl}.
Lastly, we write \AgdaBound{A}~\AgdaDatatype{⊎}~\AgdaBound{B} for the disjoint union type with constructors \AgdaInductiveConstructor{inj₁} and \AgdaInductiveConstructor{inj₂} and \AgdaFunction{¬}~\AgdaBound{A} for constructive negation.
Agda is a predicative type theory with an infinite universe hierarchy, \AgdaPrimitiveType{Setᵢ}, with \AgdaPrimitiveType{Set}---the type of small types---being identified with \AgdaPrimitiveType{Set₀}, the base universe in Agda's hierarchy.
Universe polymorphism is used extensively throughout our development, with explicit quantification over universe levels that will henceforth be ignored.

%\paragraph{Contributions and map of paper}
%\subsection{Map of Paper}
%\label{subsect.map.of.paper}
%In Section~\ref{sect.basic.definitions} we cover some definitions needed to define Dijkstra's algorithm and its correctness proof.
%In Section~\ref{sect.path.algebras.their.properties.and.models} we discuss `path algebras', a variety of algebraic structure central to our proof of correctness, also providing three models of path algebras to demonstrate that models exist and that path algebras are not categorical.
%In Section~\ref{sect.dijkstras.algorithm.and.its.correctness} we discuss the imperative Dijkstra algorithm, our functional implementation, and main body of the correctness proof leading up to our main theorem: Dijkstra's algorithm computes a right-local solution.
%In Section~\ref{sect.example} we demonstrate the algorithm in action with an example execution inside Agda.
%In Section~\ref{sect.conclusions} we conclude.
